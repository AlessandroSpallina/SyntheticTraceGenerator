#include "UEPublisherApp.h"

#include "apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.h"
#include "apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_Types.h"

#include "packets/PublisherPacket_m.h"

#include "inet/common/TimeTag_m.h"
#include "inet/common/packet/chunk/BytesChunk.h"

#include "inet/networklayer/common/L3AddressTag_m.h"
#include "inet/transportlayer/common/L4PortTag_m.h"

#include <fstream>
#include <iostream>

using namespace inet;
using namespace std;

Define_Module(UEPublisherApp);

UEPublisherApp::UEPublisherApp(){
    selfStart_ = NULL;
    selfStop_ = NULL;
}

UEPublisherApp::~UEPublisherApp(){
    cancelAndDelete(selfStart_);
    cancelAndDelete(selfStop_);
    cancelAndDelete(selfMecAppStart_);

}

void UEPublisherApp::initialize(int stage)
{
    EV << "UEPublisherApp::initialize - stage " << stage << endl;
    cSimpleModule::initialize(stage);
    // avoid multiple initializations
    if (stage!=inet::INITSTAGE_APPLICATION_LAYER)
        return;

    log = par("logger").boolValue();

    //retrieve parameters
    size_ = par("packetSize");
    period_ = par("period");
    localPort_ = par("localPort");
    deviceAppPort_ = par("deviceAppPort");
    sourceSimbolicAddress = (char*)getParentModule()->getFullName();
    deviceSimbolicAppAddress_ = (char*)par("deviceAppAddress").stringValue();
    deviceAppAddress_ = inet::L3AddressResolver().resolve(deviceSimbolicAppAddress_);

    //binding socket
    socket.setOutputGate(gate("socketOut"));
    socket.bind(localPort_);

    int tos = par("tos");
    if (tos != -1)
        socket.setTos(tos);

    //retrieving car cModule
    ue = this->getParentModule();

    //retrieving mobility module
    cModule *temp = getParentModule()->getSubmodule("mobility");
    if(temp != NULL){
        mobility = check_and_cast<inet::IMobility*>(temp);
    }
    else {
        EV << "UEPublisherApp::initialize - \tWARNING: Mobility module NOT FOUND!" << endl;
        throw cRuntimeError("UEPublisherApp::initialize - \tWARNING: Mobility module NOT FOUND!");
    }

    mecAppName = par("mecAppName").stringValue();

    //initializing the auto-scheduling messages
    selfStart_ = new cMessage("selfStart");
    selfStop_ = new cMessage("selfStop");
    selfMecAppStart_ = new cMessage("selfMecAppStart");

    //starting UEWarningAlertApp
    simtime_t startTime = par("startTime");
    EV << "UEPublisherApp::initialize - starting sendStartMEWarningAlertApp() in " << startTime << " seconds " << endl;
    scheduleAt(simTime() + startTime, selfStart_);

    //testing
    EV << "UEPublisherApp::initialize - sourceAddress: " << sourceSimbolicAddress << " [" << inet::L3AddressResolver().resolve(sourceSimbolicAddress).str()  <<"]"<< endl;
    EV << "UEPublisherApp::initialize - destAddress: " << deviceSimbolicAppAddress_ << " [" << deviceAppAddress_.str()  <<"]"<< endl;
    EV << "UEPublisherApp::initialize - binding to port: local:" << localPort_ << " , dest:" << deviceAppPort_ << endl;
}

void UEPublisherApp::handleMessage(cMessage *msg)
{
    EV << "UEPublisherApp::handleMessage" << endl;
    // Sender Side
    if (msg->isSelfMessage())
    {
        if(!strcmp(msg->getName(), "selfStart"))   sendStartMECPublisherApp();

        else if(!strcmp(msg->getName(), "selfStop"))    sendStopMECPublisherApp();

        else if(!strcmp(msg->getName(), "selfMecAppStart"))
        {
            sendMessageToMECApp();
            scheduleAt(simTime() + period_, selfMecAppStart_);
        }

        else    throw cRuntimeError("UEPublisherApp::handleMessage - \tWARNING: Unrecognized self message");
    }
    // qui non dovrebbe mai arrivarci
}

void UEPublisherApp::finish()
{

}
/*
 * -----------------------------------------------Sender Side------------------------------------------
 */
void UEPublisherApp::sendStartMECPublisherApp()
{
    inet::Packet* packet = new inet::Packet("PublisherPacket");
    auto start = inet::makeShared<DeviceAppStartPacket>();

    //instantiation requirements and info
    start->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
    start->setType(START_MECAPP);
    start->setMecAppName(mecAppName.c_str());
    //start->setMecAppProvider("lte.apps.mec.warningAlert_rest.MEWarningAlertApp_rest_External");

    start->setChunkLength(inet::B(2+mecAppName.size()+1));

    packet->insertAtBack(start);

    socket.sendTo(packet, deviceAppAddress_, deviceAppPort_);

    if(log)
    {
        ofstream myfile;
        myfile.open ("uepublisherapp.txt", ios::app);
        if(myfile.is_open())
        {
            myfile <<"["<< NOW << "] UEPublisherApp - UE sent start message to the Device App \n";
            myfile.close();

        }
    }

    //rescheduling
    scheduleAt(simTime() + period_, selfStart_);
}
void UEPublisherApp::sendStopMECPublisherApp()
{
    EV << "UEPublisherApp::sendStopMECPublisherApp - Sending STOP_MEAPP type PublisherPacket\n";

    inet::Packet* packet = new inet::Packet("DeviceAppStopPacket");
    auto stop = inet::makeShared<DeviceAppStopPacket>();

    //termination requirements and info
    stop->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
    stop->setType(STOP_MECAPP);

    stop->setChunkLength(inet::B(size_));

    packet->insertAtBack(stop);
    socket.sendTo(packet, deviceAppAddress_, deviceAppPort_);

    if(log)
    {
        ofstream myfile;
        myfile.open ("uepublisherapp.txt", ios::app);
        if(myfile.is_open())
        {
            myfile <<"["<< NOW << "] UEPublisherApp - UE sent stop message to the Device App \n";
            myfile.close();
        }
    }

    //rescheduling
    if(selfStop_->isScheduled())
        cancelEvent(selfStop_);
    scheduleAt(simTime() + period_, selfStop_);
}

/*
 * ---------------------------------------------Receiver Side------------------------------------------
 */
void UEPublisherApp::handleAckStartMECPublisherApp(cMessage* msg)
{
    inet::Packet* packet = check_and_cast<inet::Packet*>(msg);
    auto pkt = packet->peekAtFront<DeviceAppStartAckPacket>();

    if(pkt->getResult() == true)
    {
        mecAppAddress_ = L3AddressResolver().resolve(pkt->getIpAddress());
        mecAppPort_ = pkt->getPort();
        EV << "UEPublisherApp::handleAckStartMECPublisherApp - Received " << pkt->getType() << " type PublisherPacket. mecApp isntance is at: "<< mecAppAddress_<< ":" << mecAppPort_ << endl;
        cancelEvent(selfStart_);
        //scheduling sendStopMEWarningAlertApp()
        if(!selfStop_->isScheduled()){
            simtime_t  stopTime = par("stopTime");
            scheduleAt(simTime() + stopTime, selfStop_);
            EV << "UEPublisherApp::handleAckStartMECPublisherApp - Starting sendStopMECPublisherApp() in " << stopTime << " seconds " << endl;
        }
    }
    else
    {
        EV << "UEPublisherApp::handleAckStartMECPublisherApp - MEC application cannot be instantiated! Reason: " << pkt->getReason() << endl;
    }

    sendMessageToMECApp();
    scheduleAt(simTime() + period_, selfMecAppStart_);

}

void UEPublisherApp::sendMessageToMECApp(){

    //inet::Packet* pkt = new inet::Packet("PublisherPacket");
    //auto alert = inet::makeShared<PublisherPacket>();
    //alert->setType(START_WARNING);

    for (int i = 0; i < sensorCount; i++) {
        inet::Packet* pkt = new inet::Packet("PublisherPacket");
        auto req = inet::makeShared<PublisherPacket>();

        req->setSensorName(sensorNames[i]);
        req->setUnit(sensorUnits[i]);
        req->setValue(30 + (rand() % 20));
        req->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
        req->setChunkLength(inet::B(20));

        pkt->insertAtBack(req);

        socket.sendTo(pkt, mecAppAddress_ , mecAppPort_);

        EV << "SONOQUIMANDATO@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" << endl;
    }



    //alert->setCenterPositionX(par("positionX").doubleValue());
    //alert->setCenterPositionY(par("positionY").doubleValue());
    //alert->setRadius(par("radius").doubleValue());
    //alert->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
    //alert->setChunkLength(inet::B(20));
    //pkt->insertAtBack(alert);

    if(log)
    {
        ofstream myfile;
        myfile.open ("uepublisherapp.txt", ios::app);
        if(myfile.is_open())
        {
            myfile <<"["<< NOW << "] UEPublisherApp - UE sent sensors data to to the MEC application \n";
            myfile.close();
        }
    }


    EV << "UEPublisherApp::sendMessageToMECApp() - start Message sent to the MEC app" << endl;
}

void UEPublisherApp::handleInfoMEWarningAlertApp(cMessage* msg)
{

}
void UEPublisherApp::handleAckStopMECPublisherApp(cMessage* msg)
{

    inet::Packet* packet = check_and_cast<inet::Packet*>(msg);
    auto pkt = packet->peekAtFront<DeviceAppStopAckPacket>();

    EV << "UEPublisherApp::handleAckStopMECPublisherApp - Received " << pkt->getType() << " type PublisherPacket with result: "<< pkt->getResult() << endl;
    if(pkt->getResult() == false)
        EV << "Reason: "<< pkt->getReason() << endl;
    //updating runtime color of the car icon background
    ue->getDisplayString().setTagArg("i",1, "white");

    cancelEvent(selfStop_);
}
